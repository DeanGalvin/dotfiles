"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vue_eslint_parser_1 = require("vue-eslint-parser");
const ts = require("typescript");
const assert = require("assert");
const path = require("path");
const fs = require("fs");
const transformTemplate_1 = require("../transformTemplate");
const preprocess_1 = require("../preprocess");
const sourceMap_1 = require("../sourceMap");
const printer = ts.createPrinter();
function filePathToTest(filePath) {
    const vueFileSrc = fs.readFileSync(filePath, 'utf-8');
    const templateSrc = preprocess_1.parseVueTemplate(vueFileSrc);
    const syntheticSourceFileName = 'synthetic.ts';
    const validSourceFileName = 'valid.ts';
    const program = vue_eslint_parser_1.parse(templateSrc, { sourceType: 'module' });
    const syntheticSourceFile = ts.createSourceFile(syntheticSourceFileName, '', ts.ScriptTarget.ES5, false, ts.ScriptKind.JS);
    let expressions = [];
    try {
        expressions = transformTemplate_1.getTemplateTransformFunctions(ts).transformTemplate(program, templateSrc);
        preprocess_1.injectVueTemplate(ts, syntheticSourceFile, expressions);
    }
    catch (err) {
        console.log(err);
    }
    const validSource = printer.printFile(syntheticSourceFile);
    const validSourceFile = ts.createSourceFile(validSourceFileName, validSource, syntheticSourceFile.languageVersion, true /* setParentNodes: Need this to walk the AST */, ts.ScriptKind.JS);
    const sourceMapNodes = sourceMap_1.generateSourceMap(ts, syntheticSourceFile, validSourceFile);
    sourceMapNodes.forEach(node => {
        const endOffsets = [...node.mergedNodes, node].reduce((acc, node) => {
            acc.add(node.from.end);
            return acc;
        }, new Set());
        for (const fromIndex in node.offsetMapping) {
            // Only map from [start, end)
            if (!endOffsets.has(parseInt(fromIndex, 10))) {
                const toIndex = node.offsetMapping[fromIndex];
                const fromChar = templateSrc[fromIndex];
                const toChar = validSourceFile.getFullText()[toIndex];
                let errorMsg = `Pos ${fromIndex}: "${fromChar}" doesn't map to ${toIndex}: "${toChar}"\n`;
                errorMsg += `${templateSrc.slice(node.from.start, node.from.end)} should map to ${validSourceFile.getFullText().slice(node.to.start, node.to.end)}`;
                if (fromChar === `'` || fromChar === `"`) {
                    // Single/double quotes are lost during transformation
                    assert.ok([`'`, `"`].includes(toChar), errorMsg);
                }
                else {
                    assert.equal(fromChar, toChar, errorMsg);
                }
            }
        }
    });
}
suite('Source Map generation', () => {
    const repoRootPath = path.resolve(__dirname, '../../../../..');
    const fixturePath = path.resolve(__dirname, repoRootPath, './test/interpolation/fixture/diagnostics');
    fs.readdirSync(fixturePath).forEach(file => {
        if (file.endsWith('.vue')) {
            const filePath = path.resolve(fixturePath, file);
            test(`Source Map generation for ${path.relative(repoRootPath, filePath)}`, () => {
                filePathToTest(filePath);
            });
        }
    });
});
//# sourceMappingURL=sourceMap.test.js.map